<!DOCTYPE html>
<html>
	<head>
		<title>Photosynth user library</title>
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
		<meta charset="utf-8">

		<style>
		* {
			margin: 0px;
			padding: 0px;
		}

		html, body {
			font: 16px 'wf_segoe-ui_light','Segoe UI Light','Segoe WP Light','Segoe UI','Segoe WP',Tahoma,Arial,sans-serif;
			overflow: none;
			-ms-content-zooming: none;
			-ms-touch-action: none;
			touch-action: none;
		}

		#viewer-container {
			position: absolute;
			top: 0;
			left: 0;
		}
		</style>

		<script type="text/javascript" src="js/getUrlParams.js"></script>
		<script type="text/javascript">var _useCompileJS = getUrlParams().compiled === "1";</script>
		<script type="text/javascript" src="js/embedScripts.js"></script>

		<!-- ps2 viewing + annotation viewing -->
		<link rel="stylesheet" type="text/css" href="../css/PS2PacketPlayer.css" />

		<!-- annotation creation / edition -->
		<link rel="stylesheet" type="text/css" href="../css/PS2AnnotationEditor.css" />

	</head>
	<body>
		<div id="viewer-container">

			<!-- Annotation Editor layer -->
			<div class="PSAnnotationEditorLayer" style="display: none;">
				<div class="title">
					Click to add a highlight <button class="exit" title="Cancel"></button>
				</div>
				<div class="preview" style="display: none;">
					<div class="anchor"></div>
					<div class="editPanel">
						<div class="accordion selected">
							<h3>caption</h3>
							<div class="content">
								<textarea maxlength="400">Add your note</textarea>
							</div>
						</div>
						<div class="accordion">
							<h3>visibility</h3>
							<div class="content">
								<p class="visibility-explanation">Select when the highlight is visible on the synth:</p>
								<ul class="visibility-range-type">
									<li><label value="auto"  ><input type="radio" name="ps2-visibility-range-type" value="auto" checked=checked />automatic</label></li>
									<li><label value="all"   ><input type="radio" name="ps2-visibility-range-type" value="all" />show on all frames</label></li>
									<li><label value="one"   ><input type="radio" name="ps2-visibility-range-type" value="one" />only show on current frame</label></li>
									<li><label value="manual"><input type="radio" name="ps2-visibility-range-type" value="manual" />manual</label> <button class="edit"  disabled=disabled>edit visibility range</button></li>
								</ul>
							</div>
						</div>
						<div class="accordion">
							<h3>synth connection</h3>
							<div class="content">
								<p style="color: white; margin-bottom: 5px; margin-top: 5px;">Please enter target synth URL:</p>
								<input class="synth-url-selector" type="text" value="" style="width:320px; font-size: 14px;" />
								<button class="connect" disabled=disabled style="margin-left: 0px; margin-top: 10px;">connect</button>
							</div>
						</div>
						<div class="command" style="">
							<button class="cancel">cancel</button> <button class="publish" style="margin-right: 5px;">save</button>
						</div>
					</div>
				</div>
			</div>

			<!-- Annotation Visibility Control layer -->
			<div class="PSAnnotationVisibilityLayer" style="display: none;">
				<div class="toolbar">
					<p>Drag the control points to adjust when the highlight is visible.</p>
					<div class="slider-container">
						<div class="slider-handle slider-start" title="start"></div>
						<div class="slider-handle slider-stop"  title="stop"></div>
						<div class="slider-range"></div>
						<div class="slider-keyframe"></div>
						<div class="slider-container-start"></div>
						<div class="slider-container-stop"></div>
					</div>
					<button class="cancel" title="Cancel"></button> <button class="done">done</button>
				</div>
			</div>

		</div>

		<script>

		var _params = PS.Utils.getUrlParams();
		var _usePointCloud = _params.usePointCloud ? _params.usePointCloud === "1" : true; //not used

		var _guid = _params.guid || "19d5cf2b-77ed-439f-ac21-d3046320384c";
		var _startCameraIndex = _params.startat ? parseInt(_params.startat, 10) : -1;

		//Note: It's not possible to edit annotation without viewing them
		var _annotationViewingEnabled = _params.view ? _params.view === "1" : true;
		var _annotationEditingEnabled = _annotationViewingEnabled && _params.edit ? _params.edit === "1" : true;

		PS.API.SimpleAnnotationStorage.init(_annotationStorageURL, _annotationStoragePort); //test if node annotation storage service is running
		PS.API.SimpleSynthLinker.init(_simpleSynthLinkerURL, _simpleSynthLinkerPort);       //test if node synth linking service is running

		PS.Packet.Annotation.FakeViewer = {
			init:               function() {},
			onCameraChanged:    function() {},
			onCamerasChanged:   function() {},
			onPoseChanged:      function() {},
			setTransform:       function() {},
			resize:             function() {},
			load:               function() {},
			setFullscreenState: function() {},
			setLayerVisibility: function() {}
		};

		PS.Packet.Annotation.FakeEditor = {
			init:            function() {},
			start:           function() {},
			setPosition:     function() {},
			move:            function() {},
			resize:          function() {},
			onCameraChanged: function() {}
		};

		//create annotation viewer
		var _annotationViewer = _annotationViewingEnabled ? new PS.Packet.Annotation.Viewer({
			editEnabled: _annotationEditingEnabled,
			onInitialized: function() {

				//loading annotations
				PS.API.SimpleAnnotationStorage.load(_guid, function (annotations) {
					_annotationViewer.load(annotations);
				});

			},
			onAnnotationClick: function(annotation, restingCamera) {
				var annotationCamera = _player.packetViewer.dataset.cameras[annotation.camSIndex];

				if (_player.packetViewer.isPlaying()) {
					_player.packetViewer.togglePlay();
				}

				if (restingCamera === annotationCamera) {
					zoomToAnnotation(annotation);
				}
				else if (_player.seadragonViewer.isHomeZoom()) {
					_player.packetViewer.gotoCamera(annotationCamera, {
						onComplete: function() {
							zoomToAnnotation(annotation);
						}
					});
				}
				else {
					_player.seadragonViewer.goHome();
					setTimeout(function() {
						_player.packetViewer.gotoCamera(annotationCamera, {
							onComplete: function() {
								zoomToAnnotation(annotation);
							}
						});
					}, 300);
				}
			},
			onAnnotationEdit: function(annotation, tx, ty) {
				console.log("annotation edit");
				_annotationEditor.edit(annotation, tx, ty);
			},
			onAnnotationDelete: function(annotation) {
				console.log("annotation delete");
				if (window.confirm("Do you really want to delete this annotation ?")) {
					_annotationViewer.remove(annotation.id);
					console.log("annotation deleted");
					console.log(annotation);

					//deleting annotation
					PS.API.SimpleAnnotationStorage.remove(_guid, annotation);
				}
			},
			onEditedAnnotationMove: function(annotation, tx, ty) {
				_annotationEditor.move(annotation, tx, ty);
			}
		}) : PS.Packet.Annotation.FakeViewer;

		//create annotation editor
		var _annotationEditor = _annotationEditingEnabled ? new PS.Packet.Annotation.Editor(_annotationViewer, {
			alwaysUseHeuristic: true,
			onLayerVisibilityChange: function(visible) {
				console.log("edit layer is visible: " + visible);
			},
			onAnnotationPublished: function(annotation, annotationId, thumbInfo, callback) {
				console.log("annotation created ["+annotationId+"]");
				console.log(annotation);
				console.log(thumbInfo);

				if (annotation.dbid) {
					//updating annotation
					PS.API.SimpleAnnotationStorage.update(_guid, _annotationViewer.get(annotationId), function(dbid) {
						_annotationViewer.setPersistentId(annotationId, dbid);
						var succeed = true;
						callback(succeed);
					});
				}
				else {
					//inserting annotation
					PS.API.SimpleAnnotationStorage.insert(_guid, _annotationViewer.get(annotationId), thumbInfo, function(dbid) {
						_annotationViewer.setPersistentId(annotationId, dbid);
						var succeed = true;
						callback(succeed);
					});
				}
			},
			onCancel: function() {
			},
			onSynthConnectionRequested: function(request, dbid) {
				request.source.guid = _guid;
				request.source.annotationDBID = dbid;
				console.log(request);
				PS.API.SimpleSynthLinker.create(request);
			}
		}) : PS.Packet.Annotation.FakeEditor;

		var _currentCamera;

		//create viewer
		var _player = new PS.Packet.Player(document.getElementById("viewer-container"), {
			packetURL: "https://cdn.photosynth.net/ps2/"+_guid+"/packet/",
			width:  window.innerWidth,
			height: window.innerHeight,
			corsEnabled: true,
			autoResizeEnabled: true,
			onToggleFullscreen: function(fullscreen) {
				_annotationViewer.setFullscreenState(fullscreen);
			},
			viewer: {
				startCameraIndex: _startCameraIndex,
				pathToWorker: "../src/PacketPlayer/PacketViewer/WorkerParser.js",
				autoStartEnabled: false,
				progressBarEnabled: true,
				onCanvasCreated: function() {
					_annotationViewer.init(_player);
					_annotationViewer.setLayerVisibility(false);
					_annotationEditor.init(_player);
				},
				onAllGeometryLoaded: function() {
					_annotationViewer.setLayerVisibility(true);
				},
				onCameraChanged: function(cam) {
					_currentCamera = cam;
					_annotationEditor.onCameraChanged(cam);
					_annotationViewer.onCameraChanged(cam);
					window.history.replaceState(null, null, "?guid="+_guid+"&startat="+cam.sIndex);
				},
				onCamerasChanged: function(a, b) {
					_annotationViewer.onCamerasChanged(a, b);
				},
				onPositionChanged: function(qIndex) {
					_annotationEditor.setPosition(qIndex);
					_annotationViewer.onPoseChanged(_player.packetViewer.renderer.getCamera());
				},
				onPoseChanged: function() {
					_annotationViewer.onPoseChanged(_player.packetViewer.renderer.getCamera());
				},
				onContainerTransformed: function(tx, ty, scale) {
					_annotationViewer.setTransform(tx, ty, scale);
				},
				onResize: function(resizeState, mode) {
					_annotationViewer.resize(resizeState, mode);
					_annotationEditor.resize(resizeState);
				},
				onCameraModeChanged: function(mode) {
					if (mode === PS.Packet.CameraMode.Global) {
						_annotationViewer.setLayerVisibility(false);
					}
					else {
						_annotationViewer.setLayerVisibility(true);
						_annotationViewer.onPoseChanged(_player.packetViewer.renderer.getCamera());
					}
				}
			},
			seadragonViewer: {
				onResize: function() {
					_annotationViewer.onPoseChanged(_player.packetViewer.renderer.getCamera());
				},
				onZoomLevelStateChanged: function(isHomeZoom) {
					//console.log("isHomeZoomLevel: " + isHomeZoom);
				}
			},
			metadata: {
				enableAnnotate: _annotationEditingEnabled,
				onAnnotate: function() {
					_player.packetViewer.stopPlaying();
					_annotationEditor.start();
				}
			}
		});

		function zoomToAnnotation(annotation) {

			_player.packetViewer.cameraController.forceInputMode(0);

			var viewport = _player.seadragonViewer.openSeadragon.viewport;

			var scaling = 1.0 / viewport.viewportToImageZoom(viewport.getZoom());
			var radius  = annotation.accurateRadius*scaling;

			var contentSize = viewport.contentSize;
			var center      = new THREE.Vector2(contentSize.x*annotation.queryPoint.x, contentSize.y*annotation.queryPoint.y);

			var bounds = viewport.imageToViewportRectangle(new OpenSeadragon.Rect(center.x-radius, center.y-radius, radius*2, radius*2));
			_player.seadragonViewer.fitBoundsWithConstraints(bounds, false);
		}

		</script>

	</body>
</html>
